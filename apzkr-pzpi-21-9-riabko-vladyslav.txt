Міністерство освіти і науки України
Харківський національний університет радіоелектроніки

Факультет комп’ютерних наук

Кафедра програмної інженерії

КУРСОВА РОБОТА
ПОЯСНЮВАЛЬНА ЗАПИСКА
з навчальної дисципліни «Архітектура програмного забезпечення»
Тема роботи: Програмна система для автоматізації роботи таможні

Студент гр. ПЗПІ-21-9	_________________Рябко В.А.
(підпис)
Керівник роботи	____________ст.викл. Сокорчук І.П.
(підпис)
	Роботу захищено «__»_____2024р.
3 оцінкою_____________________
Комісія:	____________доц. Лещинський В.О.
(підпис)
	______________доц. Лещинська І.О.
(підпис)
	____________ст.викл. Сокорчук І.П.
(підпис)


Харків
2024 р.
Харківський національний університет радіоелектроніки  
  
Факультет комп’ютерних наук 	 	 Кафедра програмної інженерії          
Спеціальність 121 – Інженерія програмного забезпечення     	  	  	         
Курс     	3   	   Семестр    	 	6  	  	 	  	          
Навчальна дисципліна Архітектура програмного забезпечення                     

ЗАВДАННЯ  
НА КУРСОВУ РОБОТУ СТУДЕНТОВІ   

   	  	  	           Рябку Владиславу Андрійовичу 	  	          	            
1.	Тема проєкту: «Програмна система для автоматизації роботи таможні»	  	                                          	    			    
2.	Термін узгодження завдання з курсової роботи: «25» березня  2024 р.
3.	Термін здачі студентом закінченої роботи: «    »                         2024 р.
4.	Вихідні дані до проєкту: в програмній системі передбачити: унікальність, редагування та видалення багажів, речей та категорій, опрацювання декларацій та інспекцій, використовувати OC Windows 10, СУБД MongoDB,  середовище розробки Visual Studio Code. 
5.	Зміст пояснювальної записки (перелік питань, що належить розробити): вступ, аналіз предметної області, постановка задачі, проектування програмного проекту, структура бази даних, кодування програмного проекту, опис розробленої програмної системи, висновки, перелік посилань, додатки	  	  	  	  	  	  	  	                                      
6.	Перелік графічного матеріалу (з точним зображенням обов’язкових креслень): схема бази даних, діаграма варіантів використання, діаграма розгортання, інтерфейс головної сторінки  	  	  	  	
КАЛЕНДАРНИЙ ПЛАН


№ 	Назви етапів курсової роботи 	Термін виконання етапів роботи	Примітка
1 	Функціональна специфікація
програмного проєкту	27.03.2023	 виконано
2 	Проектування програмного
проєкту	16.04.2024	 виконано
3 	Кодування програмного проєкту	06.05.2024	 виконано
4 	Оформлення пояснювальної
записки	25.05.2024	 виконано
5 	 Захист курсової роботи		 не виконано

Дата видачі теми проєкту «13» березня 2024 р.  
Керівник		_________ ст. викл. Сокорчук І.П.
(підпис)


Завдання прийняв до виконання
ст.гр. ПЗПІ-21-9	_________ Рябко В.А.
(підпис)

 
РЕФЕРАТ


Пояснювальна записка до курсової роботи: 91 с., 35 рис., 3 табл., 4 додатки, 6 джерел.
БАГАЖ, ДЕКЛАРАЦІЯ, ЗАСТОСУНОК, ІНСПЕКЦІЯ, КАТЕГОРІЯ, КОРИСТУВАЧ, ПРЕДМЕТИ, СЕНСОРИ, ТАМОЖНЯ.

Об'єктом дослідження є процеси, пов'язані з роботою таможні, включаючи перевірку багажу та дотримання митних правил.
Метою курсової роботи є розробка системи автоматизації митних процедур, яка надає адміністраторам можливість створювати, редагувати та видаляти категорії та окремі речі, а також визначати їх забороненість. Користувачі можуть додавати предмети до свого багажу, та редагувати, а також видаляти багажі. Інспектори за допомогою програми автоматично перевіряють речі багажу, які вказані в базі. Інспектори здійснюють первинну перевірку речей у багажі на основі даних у базі, а далі проводять детальну перевірку за допомогою сенсорів. Це дозволяє виявити заборонені предмети та у разі їх знаходження скасовувати відправку. У разі якщо заборонених предметів не було знайдено, формується кінцева декларація яка містить в собі розрахунок митних зборів, залежно від речей в багажу.
Методи розробки використовують платформу Node.js з мовою програмування JavaScript, фреймворком Express.js та базою даних MongoDB. Веб-застосунок розроблено за допомогою бібліотеки React на мові JavaScript, смарт-пристрій було створено з використанням технології Node-RED.
У результаті роботи була реалізована програмна система для автоматизації митних процедур. Система складається з веб-додатку, смарт-пристрою для детального аналізу багажу та серверної частини.
 
ЗМІСТ


ВСТУП	7
1 АНАЛІЗ ПРЕДМЕТНОЇ ОБЛАСТІ	8
1.1	Бізнес-вимоги	8
1.1.1	Бізнес можливості	8
1.1.2 Бізнес-цілі та критерії успіху	9
1.1.3 Потреби клієнтів або ринку	9
1.1.4 Бізнес-ризики	10
1.2	Концепція рішення	11
1.2.1	Окреслення концепції	11
1.2.2	Головна функціональність	12
1.2.3	Припущення та залежності	13
1.3	Рамки та обмеження проєкту	14
1.3.1	Рамки первинного випуску	14
1.3.2 Рамки наступних випусків	16
1.3.3 Обмеження та винятки	17
1.4 Бізнес-контекст	18
1.4.1 Профілі зацікавлених сторін	18
1.4.2 Пріорітети проекту	20
1.4.3 Робоче середовище	21
2	ПОСТАНОВКА ЗАДАЧІ	22
3 ПРОЄКТУВАННЯ ТА АРХІТЕКТУРА ПРОГРАМНОЇ СИСТЕМИ	23
3.1 Проєктування серверної частини	23
3.1.1 Моделювання програмної системи	23
3.1.2 Проєктування бази даних	24
3.1.3 Технології та архітектурні рішення	26
3.1.4 Специфікація REST	27
3.2 Проектування програмної частини смарт-пристрою	30
3.2.1 Моделювання частини програмної системи смарт-пристрою	30
3.2.2 Побудова діаграми взаємодії для смарт-пристрою	32
3.2.3 Побудова діаграми діяльності смарт-пристрою	34
3.2.4 Побудова діаграми пакетів	35
3.2.5 Розробка частини смарт-пристрою	35
3.3 Проєктування клієнтської частини програмної системи	36
3.3.1 Побудова діаграми компонентів	36
3.3.2 Побудова діаграми пакетів	38
3.3.3 Побудова діаграми станів	39
3.3.4 Розробка клієнтської частини	40
4 ОПИС ПРОГРАМНОЇ СИСТЕМИ	42
4.1 Запуск застосунку	42
4.2 Опис програмної реалізації для користувача	45
4.3 Опис програмної реалізації для адміністратора	53
ВИСНОВКИ	57
ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ	58
ДОДАТОК А	59
ДОДАТОК Б	70
ДОДАТОК В	74
ДОДАТОК Г	89

 
ВСТУП


Предметна область – система автоматизації таможні - охоплює широкий спектр аспектів, пов'язаних з організацією перевірки багажу, дотриманням митних правил і забезпеченням ефективного митного контролю.
Сучасні вимоги до безпеки і ефективності митного контролю створюють високий попит на автоматизацію та оптимізацію митних процесів. Це веде до зростання необхідності вдосконалення технологій перевірки багажу. Зокрема, це вимагає інтеграції новітніх сенсорних технологій для детального аналізу вмісту багажу, що збільшує точність і швидкість процесів.
Зростання обсягу міжнародних перевезень та різноманітність товарів у багажі ставлять під сумнів ефективність традиційних методів митного контролю. Ручний перегляд і перевірка кожного багажу стають непрактичними, що підкреслює потребу в автоматизованих системах для ефективного управління.
Організація митного контролю і обробка декларацій вимагає ретельного планування та координації, щоб уникнути затримок і помилок. Важливо забезпечити ефективний моніторинг і аналіз багажу для своєчасного реагування на можливі порушення.
Конкуренція на міжнародному ринку та вимоги до підвищення рівня безпеки створюють необхідність у впровадженні інноваційних рішень для митного контролю. Це вимагає розробки комплексних систем, які забезпечать автоматизацію процесів, підвищать точність перевірки та забезпечать ефективне управління митними процедурами.
Ці проблеми демонструють потребу в комплексному рішенні - програмній системі, яка забезпечить ефективне управління всіма аспектами митного контролю та автоматизує процеси перевірки і обробки багажу.
 
1 АНАЛІЗ ПРЕДМЕТНОЇ ОБЛАСТІ
1.1	Бізнес-вимоги
1.1.1	Бізнес можливості


На ринку існує кілька програмних рішень для автоматизації праці томожні. Розглянемо деякі з них, їхні переваги та недоліки:
ASYCUDA - це система, розроблена Всемирною митною організацією, яка широко використовується для автоматизації митних процесів у різних країнах. Вона підтримує управління митними деклараціями, розрахунок митних зборів і податків, а також моніторинг і контроль за вантажами. Переваги: Система забезпечує ефективне управління деклараціями і підтримує інтеграцію з іншими митними системами. Недоліки: Може вимагати значних ресурсів для налаштування та інтеграції в існуючі інфраструктури.
NCTS - це система, що використовується в країнах ЄС для управління транзитними вантажами. Вона забезпечує автоматизований процес оформлення і моніторингу вантажів, що переміщуються через кордони. Переваги: Підвищує ефективність обробки транзитних вантажів і зменшує ризики затримок. Недоліки: Може бути складно налаштувати під специфічні потреби окремих митних органів.
SAD  - це система, що використовується в ЄС для спрощення процесу оформлення та обробки митних декларацій. Вона дозволяє використовувати єдину форму для декларації товарів. Переваги: Уніфікує процес оформлення декларацій і зменшує кількість помилок. Недоліки: Не підтримує сучасні технології і інтеграцію з мобільними платформами.
Наша програмна система пропонує наступні переваги:
‒	Налаштувальні функції: Наша система забезпечує гнучкість у налаштуванні предметів і категорій, що дозволяє митним органам у різних країнах адаптувати систему під свої специфічні потреби та вимоги.
‒	Інтуїтивно зрозумілий інтерфейс, що спрощує роботу для адміністраторів і працівників митниці.
‒	Наша система надає зручний список декларацій та інспекцій, що допомагає митним органам ефективно оцінювати та вдосконалювати митні процеси.


1.1.2 Бізнес-цілі та критерії успіху


BO-1: Міжнародне впровадження: Запустити систему у трьох країнах протягом перших шести місяців, забезпечивши високий рівень користувацького задоволення.
BO-2: Підвищення ефективності обробки: Скоротити час обробки митних декларацій на 25% за рахунок автоматизації процесів.
BO-3: Зменшення витрат на перевірки: Зменшити витрати на проведення інспекцій на 15% шляхом впровадження ефективних технологій контролю.
SC-1: Широке охоплення користувачів: Отримати не менше 60 000 активних користувачів протягом перших трьох місяців запуску.
SC-2: Виявлення контрабанди: Досягти підвищення ефективності виявлення прихованих заборонених предметів та контрабанди на 30% завдяки удосконаленню методів сканування та інспекції.
SC-3: Багатофункціональна інтеграція: Забезпечити сумісність системи з не менше ніж п'ятьма іншими важливими митними та логістичними платформами.


1.1.3 Потреби клієнтів або ринку


Види користувачів: користувачі та митні органи.

Потребами для користувачів є:
–	легкий і швидкий доступ до інформації про митні декларації через веб-сайт;
–	можливість переглядати, редагувати та видаляти інформацію про свій багаж;
–	перегляд статусу декларацій і перевірки багажу;
–	простий і безпечний процес оплати митних зборів.

Потребами для митних органів є:
‒	можливість реєстрації нових користувачів, зробити швидку та легку взаємодію з системою;
‒	можливість створення та управління категоріями товарів і предметами, що дозволяє митним органам легко адаптувати систему під специфічні вимоги;
‒	визначення заборонених предметів та встановлення цінових категорій за вагу;
‒	забезпечення інтеграції з сенсорами для детального моніторингу багажу, такими як інфрачервоні сканери, ультразвукові сканери та рентгенівські сканери, що дозволяє виявляти заборонені речовини, аномальні температури та інші аномалії.


1.1.4 Бізнес-ризики


Ризики:
‒	розгортанню програмних систем можуть перешкоджати технічні проблеми, такі як помилки в програмному забезпеченні, проблеми з безпекою даних або системні збої. Це може призвести до втрати даних, шкоди репутації бренду та значних витрат на усунення проблем;
‒	нездатність належним чином оцінити потреби клієнтів і бізнесу під час розробки системи, що може призвести до функціональних невідповідностей і відхилення нової системи користувачами;
‒	недостатня захищеність бази даних може призвести до розкриття конфіденційних даних про клієнтів або фірму, що завдасть шкоди бренду і призведе до правових проблем.

Можливі дії:
‒	забезпечення регулярного тестування системи програмного забезпечення та перевірки безпеки даних для виявлення ймовірних проблем на ранній стадії розробки, щоб зменшити ризики технічних збоїв і втрати інформації;
‒	залучання потенційних користувачів до розробки системи, щоб правильно визначити їхні потреби та вимоги. Випробувати та зібрати відгуки, щоб підтвердити, що система відповідає вимогам компанії та що нею легко керувати;
‒	застосовуння заходів підвищення безпеки даних, такі як шифрування, багаторівневий контроль доступу та періодичне оновлення механізмів безпек.


1.2	Концепція рішення 
1.2.1	Окреслення концепції


Система  призначена для забезпечення ефективного управління митними процедурами. Основна мета полягає в наданні інструментів для автоматизації процесів перевірки багажу, декларацій та забезпечення високого рівня безпеки на митниці.
Система повинна забезпечувати зручний доступ до інформації про митні декларації, дозволяючи користувачам переглядати та редагувати дані про свій багаж через веб-сайт або мобільний додаток.
Система повинна забезпечувати контроль над митними зборами, включаючи розрахунок вартості різних категорій, надання можливості оплати митних зборів і обробки платежів. Крім того, система має надавати можливість для експорту предметів, їх вартості та чи є вони забороненими.
Система повинна забезпечувати високий рівень безпеки для захисту конфіденційної інформації про багаж та дані клієнтів від несанкціонованого доступу.
Система прагне стати надійним інструментом для працівників томожні та користувачів, що допоможе оптимізувати митні процедури і підвищити ефективність перевірок.
Система має надавати можливість редагувати категорії і речі, які може перевозити користувач.
Система має коректно відображати багажі, та забезпечувати можливість редагування або видалення багажів.
Система спрямована на те, щоб стати надійним інструментом для митних органів, допомагаючи автоматизувати перевірку багажу, підвищити ефективність перевірок і забезпечити точність виявлення заборонених речовин та аномалій. Це дозволить зменшити людську помилку, прискорити процес митного контролю та підвищити загальний рівень безпеки на кордонах.


1.2.2	Головна функціональність


MF-1: Збереження основних даних про користувачів, включаючи контактну інформацію, багажі та декларації.
MF-2: Можливість створення і керування різними типами речей та категорій.
MF-3: Автоматичне створення інспекцій та декларацій, та відображення їх користувачу.
MF-4: Показ статусу декларації, швидке оновлення данних.
MF-5: Користувачі можуть користуватися застосунком англійською й українською мовами.
MF-6: Швидкий та легкий метод оплати.
MF-7: Онлайн-реєстрація нових клієнтів та створення багажу.
MF-8: Захист конфіденційної інформації про декларації та даних клієнтів від несанкціонованого доступу. Управління рівнями доступу для митників та адміністраторів системи.


1.2.3	Припущення та залежності


П-1. Припускається, що користувачі системи мають належний рівень технологічної готовності, включаючи стабільний доступ до Інтернету та сумісність із необхідними пристроями.
П-2. Припускається, що постачальники технологічних компонентів і сервісів будуть готові до інтеграції з нашою системою та надаватимуть підтримку для забезпечення безперебійної роботи.
П-3. Система повинна містити ефективні заходи безпеки для захисту від вірусів, шкідливих програм і можливих кібератак, щоб забезпечити захист даних і конфіденційність.
П-4: Інтерфейс користувача має бути інтуїтивно зрозумілим і зручним для легкого освоєння та ефективного використання системи.
З-1. Впровадження системи може бути ускладнене через необхідність інтеграції з існуючими митними та бухгалтерськими системами клієнтів.
З-2. Реалізація проекту може залежати від наявності ресурсів, включаючи людські, фінансові та матеріальні засоби для успішного завершення.
З-3. Важливо забезпечити масштабованість інфраструктури для підтримки зростаючого обсягу даних та збільшення кількості пристроїв.
З-4 Потреба в механізмах для регулярного оновлення і підтримки програмного забезпечення для забезпечення його актуальності та ефективності.


1.3	Рамки та обмеження проєкту
1.3.1	Рамки первинного випуску


Програмна система SecureBorder включає три основні компоненти: Back-end, IoT і Front-end, кожен з яких виконує ключові функції для автоматизації процесів митного контролю.

Серверна частина (Back-end):
–	реєстрація користувачів: користувачі можуть реєструватися у системі, надаючи основні особисті дані;
–	авторизація користувачів: авторизація користувачів через ідентифікатори або паролі;
–	управління категоріями та предметами: Адміністратори мають можливість отримувати інформацію про категорії та предмети, змінювати її та видаляти категорії разом с предметами;
–	сортування багажів: показ вільних багажів, та інспекцій які виконує певний працівник таможні;
–	інтеграція платіжних систем: впровадження платіжних систем для обробки оплат за митні декларації;
–	відображення декларацій та багажів користувача: Показ декларацій та багажів, які має користувач.
–	створення інспекцій: працівник митниці вибирає багаж що буде перевіряти та інпектує його.

IoT частина:
–	Infrared Scanner, Ultrasound Scanner та X-ray Scanner датчики: Використання сенсорів для перевірки багажу на наявність заборонених предметів, аномалій температури та інших небезпек. Ці пристрої допомагають автоматизувати процес перевірки, та зробити перевірку на заборонені предмети ще зручніше.
–	аналіх даних: збір даних з сканерів, обробка та аналіз отриманних даних;

Клієнтська частина (Front-end):
–	реєстрація та вхід користувачів: сторінка авторизації та інтерфейс для нових користувачів для створення облікових записів та доступу до системи;
–	локалізація: можливість вибору мови інтерфейсу (української або англійської) для зручності користувачів;
–	інтерфейс адміністраторів: інтерфейс для адміністраторів системи для управління предметами та категоріями;
–	відображення багажів та декларацій користувача, можливість создавати та редагувати багажі;
–	інтерфейс для працівника таможні, можливість вибирати багаж до інспекції, робити інспекції за допомогою системи та за допомогою iot пристрою;
–	інтерфейс для оплати декларації онлайн.

1.3.2 Рамки наступних випусків


В майбутньому проект планує розширення функціональних можливостей і вдосконалення системи для ще більшої ефективності митного контролю.

Серверна частина (Back-end):
–	впровадження інтерактивних звітів і графіків для адміністраторів, що дозволяють в реальному часі моніторити основні показники, такі як кількість перевірених багажів, статус інспекцій та фінансові операції;
–	використання алгоритмів для виявлення трендів і прогнозування можливих пікових періодів, що дозволить планувати ресурси і стратегії розвитку;
–	розробка нових аналітичних інструментів для детального аналізу даних про користувачів і багаж, що допоможе виявляти приховані закономірності і покращувати управлінські рішення. 

IoT частина:
–	додавання можливості збору детальних даних про час роботи, інтенсивність використання і відмови IoT-сенсорів. Ці дані використовуватимуться для аналізу паттернів поведінки сенсорів та виявлення аномалій, що можуть свідчити про спроби маніпуляцій або збої в системі;
–	інтеграція додаткових заходів захисту для виявлення і запобігання спробам фальсифікації даних або несанкціонованого доступу до IoT-пристроїв.

Клієнтська частина (Front-end):
–	впровадження розширених інструментів для ефективного управління великою кількістю користувачів митної систем;
–	розширення можливостей налаштування інтерфейсу відповідно до потреб митних служб. Це включає адаптацію інтерфейсу для різних типів користувачів і спеціалізованих ролей, налаштування тем і модулів відповідно до специфічних функцій митних процедур.

1.3.3 Обмеження та винятки


Обмеження:
–	Стабільність Інтернет-з'єднання: Для коректної роботи системи необхідний постійний і стабільний доступ до Інтернету. Відсутність з'єднання або низька якість зв'язку можуть негативно вплинути на функціональність системи;
–	Проблеми сумісності платформ: Деякі функції системи можуть бути обмежені через несумісність з різними операційними системами або пристроями, які використовуються користувачами. Це може вимагати додаткових налаштувань або оновлень для забезпечення безперебійної роботи;
–	Обмеження через старе обладнання: Система може не повністю підтримувати інтеграцію з застарілим обладнанням, що обмежує можливості використання нових функцій.
–	Вимоги до мережі даних: Будь-які проблеми з мережею можуть вплинути на точність даних і швидкість обробки митних декларацій.

Винятки:
–	Індивідуальні вимоги клієнтів: Для задоволення специфічних потреб клієнтів можуть бути внесені винятки щодо функціональності системи або проведені спеціальні налаштування. Це дозволяє адаптувати систему під індивідуальні вимоги і особливості користувачів;
–	Початкове налаштування і калібрування: Проблеми, що виникають через неправильне встановлення, калібрування або початкове налаштування системи, не покриваються стандартним пакетом. Виправлення таких проблем вимагатиме додаткових технічних ресурсів;
–	Надзвичайні ситуації: У разі критичних ситуацій, таких як аварії або термінові потреби користувачів, можуть бути зроблені винятки з обмежень системи для забезпечення її безперебійної роботи і швидкого реагування на екстрені ситуації.
–	Адаптація до змін у законодавстві: У випадках змін у законодавчих або регуляторних вимогах система може вимагати адаптації. Це може включати внесення змін або доповнень до функціональності для відповідності новим правовим стандартам.

1.4 Бізнес-контекст 
1.4.1 Профілі зацікавлених сторін


Профілі зацікавлених сторін проекту наведені в таблиці 1.1.

Таблиця 1.1 – Профілі зацікавлених сторін проєкту
Зацікавлена сторона	Головна цінність	Ставлення	Головні інтереси	Обмеження
Митні органи	Підвищення ефективності перевірки багажу та зменшення витрат.	Інтерес у зниженні витрат та покращенні процесів митного контролю.	Оптимізація процесів перевірки багажу, підвищення точності виявлення заборонених речовин, скорочення часу обробки декларацій.	Обмежені фінансові ресурси на впровадження нових технологій, технічні труднощі з інтеграцією.
Користувачі системи	Зручність і швидкість обробки митних декларацій та багажу.	Очікування простого і швидкого процесу оформлення і оплати митних зборів.	Легкий доступ до інформації про декларації та багажі, швидка перевірка та обробка багажу, зручний процес оплати.	Можливість складнощів у навчанні користувачів новим системам, потенційні технічні проблеми.
Розробник проєкту	Розробка та підтримка програмного забезпечення для митного контролю.	Інтерес у створенні ефективної, надійної та безпечної системи.	Забезпечення високої продуктивності системи, інтеграція з сенсорами і сканерами, постійне вдосконалення функціоналу.	Обмежені ресурси на розробку та підтримку, терміни реалізації проекту.


1.4.2 Пріорітети проекту


Пріоритети проєкту наведені в таблиці 1.2.

Таблиця 1.2 – Пріоритети проєкту
Показник	Виконання (етапи)	Обмеження (граничні значення)	Ступінь свободи (допустимий діапазон)
План робіт	Проєкт має бути реалізований до 08.06.2024		Можливе відхилення від графіку на 1 місяць

Функціональність			Допустиме відхилення у функціональності до 5%
Якість			У релізі 1.0 повинні пройти 100% тестувань
Персонал		Максимальний розмір команди – один розробник.	
Ціна		5000 гривень	Модливе збільшення на 15%


1.4.3 Робоче середовище


Програмна система для автоматизації роботи таможні буде розгорнута на хмарних сервісах Amazon Web Services (AWS), що забезпечить безперервний доступ для користувачів з будь-якої країни. Система буде орієнтована на глобальний ринок, тому важливо забезпечити надійну та ефективну хмарну інфраструктуру для підтримки її функціональності. Для розширення доступності також буде додана локалізація (для української та англійської мов).
Для зберігання даних буде використовуватися база даних MongoDB, яка є NoSQL рішенням і добре підходить для обробки великої кількості даних, що характерно для митних декларацій та перевірок багажу.
Серверна частина системи буде розроблена з використанням Node.js, що дозволяє забезпечити високу продуктивність і швидкість обробки запитів. Для створення API та маршрутизації буде застосовуватися веб-фреймворк Express.js.
Веб-застосунок буде розроблено з використанням бібліотеки React.js для забезпечення динамічного та інтерактивного інтерфейсу користувача. Середовищем розробки для веб-застосунку буде Visual Studio Code.
 
2	ПОСТАНОВКА ЗАДАЧІ


Згідно з аналізом предметної області та завданням курсової роботи, передбачено створення програмної системи для автоматизації роботи таможні. Система повинна забезпечити ефективне управління даними та підтримку всього процесу перевірки багажу.
База даних повинна включати інформацію про: користувачів, багажі, категорії, предмети, інспекції та декларації.
Для клієнта має бути реалізований наступний функціонал:
–	Реєстрація, авторизація та вхід у систему;
–	Перегляд декларацій та багажів користувача;
–	Експорт декларацій користувача;
–	Перегляд та редагування власного профілю;
–	Додання багажу;
–	Редагування та видалення багажу;
–	Оплата деклаарції;
Для працівника таможні має бути реалізований наступний функціонал:
–	Перегляд вільних багажів для інспекції;
–	Взяття багажу на інспекцію;
–	Перегляд багажів, закріплених за працівником;
–	Інспекція багажу. Доп інспекція багажу за допомогою датчиків.
Для адміністратора має бути реалізований наступний функціонал:
–	Реєстрація, авторизація та вхід у систему;
–	Перегляд усіх предметів;
–	Експорт усіх предметів;
–	Перегляд усіх категорій
–	Додавання, редагування та видалення категорій;
–	Додавання, редагування та видалення предметів;
 
3 ПРОЄКТУВАННЯ ТА АРХІТЕКТУРА ПРОГРАМНОЇ СИСТЕМИ
3.1 Проєктування серверної частини
3.1.1 Моделювання програмної системи


Серед користувачів програмної системи є 3 типи акторів: звичайний користувач (пасажир, власник багажу), працівник таможні та адміністратор. 
Взаємодія акторів та системи представлена на діаграмі прецедентів (див. рис. 3.1).

 
Рисунок 3.1 – Діаграма прецедентів

За діаграмою прецедентів було визначено функціональні вимоги та спосіб взаємодії акторів та програмної системи.
Звичайний користувач, тобто пасажир може реєструватися та заходити в систему. Переглядати та редагувати свій профіль. Створювати, редагувати та видаляти свої багажі. Також користувач може переглядати свої декларації, експортувати їх та оплачувати.
Працівник таможні може реєструватися та заходити в систему. Переглядати та редагувати свій профіль. Переглядати доступні до інспекції багажі, брати їх на інспекцію, переглядати список багажів яких він взяв до перевірки, інспектувати багаж, залишати примітки, а також роботи додаткову інспекцію за допомогою сканерів.
Адміністратор може заходити в систему. Переглядати та редагувати свій профіль. Переглядати категорії, видаляти, змінювати та додавати їх. Адміністратор може переглядати предмети, експортувати їх, змінювати, додавати да видаляти.


3.1.2 Проєктування бази даних


Для проектування бази даних була розроблена ER-модель даних (див. рис. 3.2), що складається з 6 таблиць: користувачі (User), інспекції (Inspection), багажі (Baggage), декларації (Declaration), предмети (Item) та категорії (Category).

 
Рисунок 3.2 – ER-модель даних

Виникли наступні зв’язки між сутностями при проектуванні бази даних:
1. Користувач – Багаж (один до багатьох, один користувач може мати декілька багажів)
2. Користувач – Декларація (один до багатьох, один користувач може мати декілька декларацій)
3. Багаж – Предмет (один до багатьох, в одному багажі може бути декілька предметів)
4. Предмет – Категорія (один до багатьох, один предмет може мати декілька категорій)
5. Декларація – Багаж (один до одного, одна декларація може мати тільки один багаж)
6. Декларація – Інспекція (один до одного, одна декларація може мати тільки одну інспекцію)
7. Інспекція – Користувач (інспектор) (один до багатьох, один інспектор може провести декілька інспекцій).


3.1.3 Технології та архітектурні рішення


Серверну частину було створено на Node.js з використанням фреймворку Express.js. 
Для роботи з базою даних було обрано MongoDB, доступ до якої здійснюється за допомогою бібліотеки Mongoose, яка забезпечує інструменти для валідації та побудови схем даних. 
З метою візуалізації використаних технологій була розроблена діаграма розгортання (див. рис. 3.3).

 
Рисунок 3.3 – Діаграма розгортання

3.1.4 Специфікація REST


Програмна система реалізує REST API, що включає 37 кінцевих точок. Ці кінцеві точки забезпечують інформацію як для користувачів, так і для адміністраторів, а також реалізують бізнес-логіку. Детальна специфікація REST API представлена в таблиці 3.1.

Таблиця 3.1 – Специфікація REST API
Посилання на кінцеву точку	Метод HTTP	Необхідна роль	Опис роботи
/login	POST	-	Авторизація користувача
/register	POST	-	Реєстрація користувача
/users	GET	admin	Отримання всіх користувачів з деталями багажу та декларацій
/user/:id	GET	user	Отримання деталей певного користувача
/user/:id	PUT	user	Оновлення деталей певного користувача
/user/:id	DELETE	user	Видалення певного користувача
/user/:id/change-password	PUT	user	Зміна паролю користувача
/user/pay	POST	user	Оплата декларації користувачем
/baggage	GET	admin	Отримання усіх багажів
/ baggage/:id	GET	user	Отримання інформації про конкретний багаж
/baggage	POST	user	Створення нового багажу
/baggage/:id	PUT	user	Редагування даних багажу
/baggage/:id	DELETE	user	Видалення багажу
/baggage/:id/add-item	POST	user	Додання предмету до багажу
/categories	GET	admin	Отримання усіх категорій предметів
/category/:id	GET	admin	Отримання інформації про певну категорію
/category	POST	admin	Створення нової категорії
/category/:id	PUT	admin	Редагування категорії
/category/:id	DELETE	admin	Видалення категорії
/declaration	POST	admin	Створення нової декларації
/declarations/under_review	GET	admin	Отримання усіх декларацій зі статусом under_review
/:userId/declaration	GET	user	Отримання усіх декларацій користувача
/declaration/:id	GET	user	Отримання інформації про конкретну декларацію
/declaration/:id	PUT	admin	Редагування статусу або загальної вартості декларації
/export-declarations/:userId	GET	user	Експорт усіх декларацій користувача
/export-items	GET	admin	Експорт усіх предметів та їх категорій
/inspection	POST	admin	Створення нової інспекції
/doinspection	POST	admin	Проведення інспекції та оновлення статусу
/:userId/inspections	POST	admin	Отримання всіх інспекцій для певного інспектора
/inspection/:id	GET	admin	Отримання деталей певної інспекції
/inspection/:id	PUT	admin	Оновлення статусу та приміток певної інспекції
/finalinspection	POST	admin	Проведення остаточної інспекції з використанням датчиків.
/items	GET	user	Отримання всіх предметів
/item/:id	GET	admin	Отримання деталей певного предмета
/item	POST	admin	Створення нового предмета
/item/:id	PUT	admin	Оновлення інформації певного предмета
/item/:id	DELETE	admin	Видалення певного предмета
У такий спосіб було визначено основні кінцеві точки для HTTP запитів до серверної частини застосунку.


3.2 Проектування програмної частини смарт-пристрою
3.2.1 Моделювання частини програмної системи смарт-пристрою


В програмній системі автоматизації лише працівник таможні взаємодіє з розробленим IoT-модулем. Інші актори не мають безпосереднього доступу до цього модуля.
Взаємодію акторів з програмною системою представлено на діаграмі прецедентів (рис. 3.4).

 
Рисунок 3.4 – Діаграма прецедентів

Таким чином, працівник перевіряє багаж за допомогою 3 різних сканерів, ультразвукового, інфрачервоного та рентгенівського. Дані зі сканерів збираються та аналізуються, відсилая результат на сервер. У разі знаходження контрабандних предметів, вибухових матеріалів, температурних аномалій інспекція відмічається як небезпечна та декларація відміняється, у іншому випадку додаткова інспекція є пройденою, та користувач може оплачувати свій митний платіж.
	IoT-пристрій реалізовано за допомогою Node-RED, який використовується для проектування логіки обробки даних, налаштування з'єднань з пристроями через HTTP, обробки даних у реальному часі і моніторингу стану пристроїв через веб-інтерфейс.

3.2.2 Побудова діаграми взаємодії для смарт-пристрою


Для опису взаємодії між IoT пристроями та системою була застосована UML діаграма взаємодії (див. рис. 3.5).

 
Рисунок 3.5 – Діаграма взаємодії

Після сканування багажу користувача проаналізовані дані надсилаються на сервер. Інспекція змінює свій статус відповідно до результатів перевірки. Якщо виявлено заборонені предмети, інформація про проблеми додається до приміток інспекції. 


3.2.3 Побудова діаграми діяльності смарт-пристрою


Для визначення процесу використання IOT частини програмного застосунку було побудовано діаграму діяльності (рис. 3.6).

 
Рисунок 3.6 - UML діаграма діяльності

Під час сканування багажу, якщо виникає помилка при передачі даних, інспекція відхиляється, оскільки можливе видалення багажу власником. Якщо ж передача даних є успішною, багаж сканується, інформація аналізується та надсилається на сервер для подальшої обробки.


3.2.4 Побудова діаграми пакетів


Для демонстрації внутрішньої архітектури програмної системи була створена UML діаграма пакетів (рис. 3.7).

 
Рисунок 3.7 - UML діаграма пакетів

Основним набором є пакет Node-RED Flow, який визначає всі взаємодії та системну логіку. Core Functions містять функціональні блоки, які виконують основні операції, наприклад зберігання даних. Dashboard Nodes містить набір вузлів для створення графічних інтерфейсів користувача, переважно для тестування. Пакет модулів пристроїв IoT містить спеціальні модулі для різних пристроїв IoT, що забезпечують взаємодію з реальними датчиками та пристроями.


3.2.5 Розробка частини смарт-пристрою


Для реалізації IOT частини було інтегровано Node-RED у програмну систему через використання npm.
Для розшифрування QR-коду було використано вузол qrdecode, а запити на сервер реалізовані через вузли http.
Було створено потік даних, що приймав запит на сканування коду. Створено функцію для обробки вхідних даних для їх подальшого розшифрування. Додано функцію для обробки розшифрованих даних та функцію для приведення їх до формату JSON для подальшої участі у http запитах до сервера.
Було створено кінцеву точку для серверної частини, яка зберігала дані у базі даних.


3.3 Проєктування клієнтської частини програмної системи
3.3.1 Побудова діаграми компонентів


Для розробки клієнтської частини була створена UML діаграма компонентів (див. рис. 3.8), яка ілюструє архітектуру системи та показує, як її різні компоненти взаємодіють між собою.

 
Рисунок 3.8 - Діаграма компонентів

Були виділені наступні компоненти:
‒	Baggages – Відображення інформації про багаж, користувача, предмети та їх вагу;
‒	Declarations –  Відображення всіх митних декларацій та їх статусів;
‒	ExportDeclarations – Експорт усіх декларацій певного користувача;
‒	Inspection  – Відображення усіх інспекцій у яких приймає участь робітник таможні, можливість робити інспекції;
‒	Catrgories – Відображення всіх категорій предметів, інформації про їх забороненість та вартість перевезення;
‒	Items – Відображення всіх предметів, їхніх категорій та ваги;
‒	ExportItems – Експорт усіх предметів та їх категорій;


3.3.2 Побудова діаграми пакетів


Пакети, що формують структуру програмної системи, були виділені за допомогою створення діаграми пакетів (див. рис. 3.9).
Основний рівень архітектури включає наступні пакети: пакет для статичних файлів (assets), пакети для стилів (styles), пакет з вихідним кодом (src), пакет з компонентами системи (components), а також пакет для публічних статичних файлів і точка входу в систему (public).

 
Рисунок 3.9 – Діаграма пакетів


3.3.3 Побудова діаграми станів


Інтерфейси та основні функції, які надаються клієнтською частиною, були виділені шляхом створення UML діаграми станів (рис. 3.10).
  
Рисунок 3.10 – Діаграма станів

Було отримано наступні функції та інтерфейси, що надає клієнтська частина:
–	Авторизація: Інтерфейс для авторизація користувача;
–	Реєстрація: Інтерфейс для реєстрації користувача;
–	Профіль: Інтерфейс для відображення даних про користувача, редагування та навігації по додатку в залежності від ролі;
–	Категорії: Інтерфейс для створення, редагування та видалення категорій предметів;
–	Речі: Інтерфейс для створення, редагування та видалення предметів для багажу;
–	Декларації: Інтерфейс для перегляду та експорту декларацій користувача;
–	Багажі: Інтерфейс для створення, видалення та редагування багажів користувача. Також інтерфейс для пошуку вільних багажів до інспекції;
–	Інспекції: Інтерфейс для перегляду інспекцій, інспектування багажу та додаткової перевірки багажу за допомогою IoT модулю.
Отримано діаграму станів, що показує поведінку клієнтської частини, що залежить від її поточного стану.


3.3.4 Розробка клієнтської частини


Для розробки клієнтської частини програмної системи було обрано React.js, який використовує JavaScript.
Клієнтська частина забезпечує графічний інтерфейс для реалізації бізнес-логіки системи. 
‒	Відображення багажів користувача, інформації про багаж, включаючи можливість редагування даних про кожен багаж, а також можливість додавання нових багажів і видалення існуючих.
‒	Відображення профілю користувача з можливістю його редагування. Перегляд декларацій користувача, та оплата митних податків. Можливість експорту всіх декларацій користувача.
‒	Можливість створювати, редагувати та видаляти предмети і їх категорії. Система дозволяє уточнювати ціну перевезення для певних категорій предметів, а також визначати, чи є ці категорії забороненими.
‒	Експортувати список предметів і їх категорій. Адміністратору на комп’ютер буде завантажено дані у вигляді excel файлу.
‒	Можливість проводити інспекції багажу для визначення наявності заборонених предметів. Система підтримує використання сканерів для виконання додаткових інспекцій.
Згідно з вимогами захисту даних, паролі користувачів не відображаються під час перегляду їхньої інформації. Вони також шифруються, щоб забезпечити їх захист у базі даних. Під час авторизації кожному користувачу генерується унікальний токен для кожної сесії, що реалізовано за допомогою технології JWT.
 
4 ОПИС ПРОГРАМНОЇ СИСТЕМИ
4.1 Запуск застосунку


Для того щоб запустити програму, необхідно завантажити архів з репозиторію та розпакувати його. Завантажені файли треба відкрити у середовищі розробки, наприклад Visual Studio Code.
Для того щоб запустити серверну частину треба запустити файл index.js. Після цього у терміналі з'явиться підтвердження про успішний запуск сервера та встановлення з'єднання з базою даних (див. рис. 4.1).

 
Рисунок 4.1 – Запуск серверної частини

Після цього потрібно запустити клієнтську частину. Виконуємо команду “npm run start” у терміналі. Після виконання програми в браузері відриється сторінка з програмою (див. рис. 4.2). 

 
Рисунок 4.2 – Запуск клієнтської частини

Після того як серверна та клієнтська частини запущені, наступним кроком є налаштування взаємодії зі смарт-пристроєм. Для цього потрібно налаштувати Node-RED. Відкрийте командний рядок і виконайте команду npm «install -g --unsafe-perm node-red». о завершенню установки, запустіть Node-RED, використовуючи команду «node-red» (див. рис. 4.3).

 
Рисунок 4.3 – Запуск частини смарт-пристрою

Далі треба перейти за адресою http://localhost:1880/. Це відкриє інтерфейс системи Node-RED. У веб інтерфейсі треба знайти кнопку імпорту та імпортувати файл за репозиторію. Після усіх дій треба розгорнути систему вузлів (див. рис. 4.4).

 
Рисунок 4.4 – Розгорнута частина смарт-пристрою

Після завершення розгортання системи вузлів, ваш додаток повністю готовий до використання. Тепер можна повернутися на сторінку клієнтської частини в браузері та розпочати роботу з додатком.


4.2 Опис програмної реалізації для користувача


При запуску клієнтського застосунку відкривається головна сторінка з привітанням і описом проекту, а також зазначається, що для доступу до всіх функцій необхідно увійти в систему (див. рис. 4.5).
З головної сторінки можна потрапити на сторінку авторизації та реєстрації, основна функціональність є саме у авторизованих користувачів.

 
Рисунок 4.5 – Головна сторінка

На сторінці авторизації (див. рис. 4.6) користувачі можуть увійти до свого облікового запису або перейти до сторінки реєстрації для створення нового акаунта.

 
Рисунок 4.6 – Сторінка авторизації

На сторінці реєстрації необхідно вказати ім’я користувача, електронну адресу, телефон, пароль і вибрати роль (див. рис. 4.7). Після завершення реєстрації користувач буде перенаправлений на сторінку входу для авторизації в системі.

 
Рисунок 4.7 – Сторінка реєстрації


Після успішного входу користувач може переглянути дані свого облікового запису. Залежно від ролі на сторінці профілю буде доступний різний функціонал. Якщо користувач є пасажиром (або власником багажу), то він зможе перейти на сторінку з багажем, переглянути свої декларації та експортувати їх (див. рис. 4.8). Кнопки редагування профілю та виходу із системи доступні всім користувачам, незалежно від ролі.

 
Рисунок 4.8 – Обліковий запис користувача

Якщо перейти на сторінку редагування профілю, можна змінювати ім’я, електронну пошту, телефон, роль користувача та пароль (див. рис. 4.9).

 
Рисунок 4.9 – Редагування облікового запису

При переході на сторінку багажу відображаються всі багажі користувача, їх вага, а також кнопки для редагування та видалення багажу (див. рис. 4.10). При створенні нового багажу можна додавати предмети та вказувати їх кількість (див. рис. 4.11). 

 
Рисунок 4.10 – Сторінка з багажами, редагування багажу

 
Рисунок 4.11 – Створення багажу


Перейшовши на декларацій можна побачити усі декларації користувача (див. рис. 4.12). Якщо декларація була перевірена то можна заплатити митний податок через форму (див. рис. 4.13).

 
Рисунок 4.12 – Сторінка декларацій користувача

 
Рисунок 4.13 – Оплата декларації

Також можна експортувати усі декларації користувача, вони будуть мати вигляд таблиць Excel з даними декларацій (див. рис. 4.14). 
 
Рисунок 4.14 – Експорт декларацій

Після входу в систему як працівник таможні, можна перейти на сторінку вибору багажів для проведення інспекцій, а також на сторінку своїх інспекцій (див. рис. 4.15).

 
Рисунок 4.15 – Профіль працівника таможні

Перейшовши на сторінку багажів для інспекцій, працівник може вибрати з переліку вільних багажів той, який він бажає проінспектувати (див. рис. 4.16).

 
Рисунок 4.16 – Сторінка перегляду вільних багажів

Після взяття багажу до інспекції, працівник переходить на сторінку своїх інспекцій. Тут він може переглядати свої інспекції, перевіряти нові багажі та залишати нотатки щодо проведеної перевірки (див. рис. 4.17). Після цього працівник може виконати додаткову перевірку за допомогою сканерів (IoT-модулю) (див. рис. 4.18).

 
Рисунок 4.17 – Інспекції користувача

 
Рисунок 4.18 – Виконати додаткову перевірку

Було описано можливості взаємодії користувача з розробленою програмною системою.

4.3 Опис програмної реалізації для адміністратора


Сторінка реєстрації та авторизації для адміністратора аналогічні відповідним сторінкам для користувача. 
Після входу в систему як адміністратор, можна перейти на сторінку управління категоріями та сторінку управління предметами (див. рис. 4.19).  Також можна експортувати всі предмети разом із їх категоріями, включаючи інформацію про те, чи є предмети забороненими чи ні (див. рис. 4.20).

 
Рисунок 4.19 – Профіль адміністратора

 
Рисунок 4.20 – Експорт предметів та їх категорій

На сторінці управління категоріями відображаються всі категорії, вартість їх перевезення та інформація про те, чи є вони забороненими чи ні. Крім того, можна додати нову категорію, вказавши її дані (див. рис. 4.21).

 
Рисунок 4.21 – Сторінка управління категоріями

Аналогічно, на сторінці управління предметами можна переглядати всі предмети, додавати нові та редагувати вже існуючі (див. рис. 4.21).

 
Рисунок 4.22 – Сторінка управління предметами

Було описано можливості взаємодії адміністратора з розробленою програмною системою. Для розширення розуміння функціоналу є посилання на відеоматеріали курсової роботи[6]. 
 
ВИСНОВКИ


На основі виконаної роботи була розроблена програмна система для автоматизації роботи митниці. У процесі створення системи було проведено глибокий аналіз предметної області, спроектовано базу даних, серверну та клієнтську частини, а також модуль для смарт-пристроїв. Реалізація системи здійснена з використанням Node.js і Express.js для серверної частини, React.js для клієнтської частини та Node-RED для інтеграції смарт-пристроїв.
Розроблена система дозволяє користувачам створювати та редагувати інформацію про багаж, переглядати та експортувати декларації, а також оплачувати їх. Крім того, система забезпечує автоматичне оновлення статусу багажу, що дозволяє користувачам завжди бути в курсі його стану.
	Для працівників митниці система надає можливість вибирати вільні багажі для інспекції, проводити перевірки, залишати нотатки щодо інспекцій, а також здійснювати додаткові перевірки на заборонені речовини, контрабанду та аномалії за допомогою сканерів. 
Адміністратори мають можливість управляти категоріями предметів, контролювати вартість їх перевезення та визначати, чи є вони забороненими. Вони можуть додавати нові предмети та редагувати існуючі. Система також підтримує експорт даних про предмети та їх категорії для подальшої обробки та аналізу.
 
ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ


1.	Node.js v20.8.0 Documentation. Node.js Documentation. URL: https://nodejs.org/dist/latest-v20.x/docs/api/ (дата звернення: 24.08.2024).
2.	Express - Node.js web application framework. Express.js Documentation. URL: https://expressjs.com/en/5x/api.html (дата звернення: 26.04.2024).
3.	React documentation. URL: https://legacy.reactjs.org/docs/react-api.html (дата звернення: 02.06.2024).
4.	Мартін Р. Чистий код: створення і рефакторинг за допомогою AGILE. – ФАБУЛА, 2019. – 416 с.
5.	Design Patterns: Elements of Reusable Object-Oriented Software. Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides, 1994. 395 р.
6.	Відеозапис курсової роботи, відеоматеріали реалізованого проекту. URL: https://youtu.be/4gSUxi_E_Vc 
ДОДАТОК А
Програмний код серверної частини
А.1 Код основного файлу серверної частини index.js:


1 const express = require('express');
2 const mongoose = require('mongoose');
3 const cors = require('cors');
4 const dotenv = require('dotenv');
5 
6 const authRouter = require('./routes/auth');
7 const baggageRouter = require('./routes/baggage');
8 const categoryRouter = require('./routes/category');
9 const declarationRouter = require('./routes/declaration');
10 const itemRouter = require('./routes/item');
11 const userRouter = require("./routes/user");
12 const inspectionRouter = require('./routes/inspection');
13 const exportRouter = require('./routes/export');
14 const auth = require('./validation/auth');
15 
16 const authValidation = require('./validation/auth');
17 const adminValidation = require('./validation/admin');
18 
19 const Baggage = require("./models/Baggage");
20 const Category = require("./models/Category");
21 const Declaration = require("./models/Declaration");
22 const Item = require("./models/Item");
23 const User = require("./models/User");
24 const Inspection = require("./models/Inspection");
25 
26 dotenv.config();
27 
28 const app = express();
29 const port = process.env.PORT || 3001;
30 
31 mongoose.connect(process.env.MONGODB_URI)
32     .then(() => console.log('Connected to MongoDB'))
33     .catch(err => console.error('Could not connect to MongoDB', err));
34 
35 app.use(cors());
36 app.use(express.json());
37 
38 app.use('/auth', authRouter);
39 app.use('/baggage', auth, baggageRouter);
40 app.use('/category', auth, categoryRouter);
41 app.use('/declaration', auth, declarationRouter);
42 app.use('/item', auth, itemRouter);
43 app.use('/inspection', auth, inspectionRouter);
44 app.use('/user', auth, userRouter);
45 app.use('/export', auth, exportRouter);
46 app.listen(port, () => {
47     console.log(`Server is running on port ${port}`);
48 });

А.2 Код логіки додання багажу з файлу baggage.js


1 router.post('/baggage', auth, async (req, res) => {
2     try {
3         const { owner, itemsList } = req.body;
4 
5         const items = await Items.find({ '_id': { $in: itemsList.map(item => item.item) } });
6 
7         let totalWeight = 0;
8         for (const item of items) {
9             const itemDetails = itemsList.find(i => i.item.toString() === item._id.toString());
10             if (itemDetails) {
11                 totalWeight += item.weight * itemDetails.quantity;
12             }
13         }
14 
15         const baggage = new Baggage({
16             owner,
17             itemsList,
18             totalWeight
19         });
20 
21         const newBaggage = await baggage.save();
22 
23         const declaration = new Declaration({
24             passenger: owner, 
25             baggage: newBaggage._id,
26             status: 'under_review' 
27         });
28 
29         const newDeclaration = await declaration.save();
30 
31         await User.findByIdAndUpdate(owner, {
32             $push: {
33                 baggage: newBaggage._id,
34                 declarations: newDeclaration._id
35             }
36         });
37 
38         res.status(201).json({
39             baggage: newBaggage,
40             declaration: newDeclaration
41         });
42     } catch (err) {
43         res.status(400).json({ message: err.message });
44     }
45 });


А.3 Код для створення інспекції inspection.js


1 router.post('/inspection', async (req, res) => {
2     const { declaration, inspector, notes } = req.body;
3 
4     try {
5         const inspection = new Inspection({
6             declaration,
7             inspector,
8             notes: notes || '',
9             status: 'waiting_for_inspection' 
10         });
11 
12         const newInspection = await inspection.save();
13 
14         const updatedDeclaration = await Declaration.findByIdAndUpdate(
15             declaration,
16             {
17                 inspection: newInspection._id,
18                 status: 'waiting_for_inspection'
19             },
20             { new: true }
21         );
22 
23         res.status(201).json({
24             inspection: newInspection,
25             declaration: updatedDeclaration
26         });
27     } catch (err) {
28         res.status(400).json({ message: err.message });
29     }
30 });

А.4 Код логіки експорту даних export.js


1 const express = require('express');
2 const fs = require('fs');
3 const path = require('path');
4 const ExcelJS = require('exceljs');
5 const Item = require('../models/Item');
6 const Declaration = require('../models/Declaration');
7 const User = require('../models/User');
8 const Baggage = require('../models/Baggage');
9 const Inspection = require('../models/Inspection');
10 const router = express.Router();
11 
12 router.get('/export-items', async (req, res) => {
13     try {
14         console.log('Exporting all items');
15 
16         const items = await Item.find().populate('category');
17         if (items.length === 0) {
18             console.error('No items found');
19             return res.status(404).send('No items found');
20         }
21 
22         const ExcelJS = require('exceljs');
23         const path = require('path');
24         const fs = require('fs');
25 
26         const workbook = new ExcelJS.Workbook();
27         const worksheet = workbook.addWorksheet('Items');
28 
29         worksheet.columns = [
30             { header: 'Name', key: 'name', width: 30 },
31             { header: 'Category', key: 'category', width: 30 },
32             { header: 'Description', key: 'description', width: 50 },
33             { header: 'Weight', key: 'weight', width: 15 },
34             { header: 'Status', key: 'status', width: 20 },
35         ];
36 
37         items.forEach(item => {
38             const status = item.category && item.category.isProhibited ? 'Prohibited' : 'Allowed';
39             const statusColor = status === 'Prohibited' ? 'FF0000' : '00FF00';
40             const row = worksheet.addRow({
41                 name: item.name,
42                 category: item.category ? item.category.name : 'No category',
43                 description: item.description || 'No description',
44                 weight: item.weight,
45                 status: status,
46             });
47 
48             row.getCell('status').font = { color: { argb: statusColor } };
49         });
50 
51         const dirPath = path.join(__dirname, 'temp');
52         if (!fs.existsSync(dirPath)) {
53             fs.mkdirSync(dirPath, { recursive: true });
54         }
55 
56         const filePath = path.join(dirPath, 'all_items.xlsx');
57         console.log(`Saving file to: ${filePath}`);
58 
59         await workbook.xlsx.writeFile(filePath);
60         console.log('File saved successfully');
61 
62         res.download(filePath, 'all_items.xlsx', (err) => {
63             if (err) {
64                 console.error('Failed to download the file:', err.message);
65                 res.status(500).json({ message: 'Failed to download the file', error: err.message });
66             } else {
67                 console.log('File sent successfully');
68             }
69         });
70 
71     } catch (error) {
72         console.error('Error exporting items:', error.message);
73         res.status(500).send(error.message);
74     }
75 });
76 
77 router.get('/export-declarations/:userId', async (req, res) => {
78     try {
79         const userId = req.params.userId;
80         console.log(`Exporting declarations for user: ${userId}`);
81 
82         if (!userId) {
83             return res.status(400).send('User ID is required.');
84         }
85 
86         const declarations = await Declaration.find({ passenger: userId })
87             .populate('passenger') 
88             .populate('baggage'); 
89 
90         if (declarations.length === 0) {
91             console.error('No declarations found for the user');
92             return res.status(404).send('No declarations found for the user');
93         }
94 
95         const workbook = new ExcelJS.Workbook();
96         const worksheet = workbook.addWorksheet('Declarations');
97 
98         worksheet.columns = [
99             { header: 'Passenger', key: 'passenger', width: 30 },
100             { header: 'Baggage Details', key: 'baggage', width: 50 },
101             { header: 'Total Cost', key: 'totalCost', width: 15 },
102             { header: 'Status', key: 'status', width: 25 },
103         ];
104 
105         for (const declaration of declarations) {
106             let baggageDetails = 'No baggage';
107             if (declaration.baggage) {
108                 const baggage = declaration.baggage;
109                 const itemDetails = await Promise.all(baggage.itemsList.map(async (itemEntry) => {
110                     const item = await Item.findById(itemEntry.item);
111                     return item ? `${item.name} (Quantity: ${itemEntry.quantity})` : `Unknown Item (Quantity: ${itemEntry.quantity})`;
112                 }));
113 
114                 baggageDetails = `Weight: ${baggage.totalWeight} kg, Items: ${itemDetails.join(', ')}`;
115             }
116 
117             worksheet.addRow({
118                 passenger: declaration.passenger ? declaration.passenger.email : 'No passenger',
119                 baggage: baggageDetails,
120                 totalCost: declaration.totalCost || 0,
121                 status: declaration.status || 'No status',
122             });
123         }
124 
125         const dirPath = path.join(__dirname, 'temp');
126         if (!fs.existsSync(dirPath)) {
127             fs.mkdirSync(dirPath, { recursive: true });
128         }
129 
130         const filePath = path.join(dirPath, `user_${userId}_declarations.xlsx`);
131         console.log(`Saving file to: ${filePath}`);
132 
133         await workbook.xlsx.writeFile(filePath);
134         console.log('File saved successfully');
135 
136         res.download(filePath, `user_${userId}_declarations.xlsx`, (err) => {
137             if (err) {
138                 console.error('Failed to download the file:', err.message);
139                 res.status(500).json({ message: 'Failed to download the file', error: err.message });
140             } else {
141                 console.log('File sent successfully');
142             }
143         });
144 
145     } catch (error) {
146         console.error('Error exporting declarations:', error.message);
147         res.status(500).send(error.message);
148     }
149 });
150 
151 
152 module.exports = router;

A.5 Код логіки перевірки багажу з файлу inspection.js


1 router.post('/doinspection', async (req, res) => {
2     const { inspectionId } = req.body;
3 
4     try {
5         const inspection = await Inspection.findById(inspectionId).populate({
6             path: 'declaration',
7             populate: {
8                 path: 'baggage',
9                 populate: {
10                     path: 'itemsList.item',
11                     populate: 'category'
12                 }
13             }
14         });
15 
16         if (!inspection) {
17             return res.status(404).json({ message: 'Inspection not found' });
18         }
19 
20         const declarationData = inspection.declaration;
21         if (!declarationData) {
22             return res.status(404).json({ message: 'Declaration not found' });
23         }
24 
25         let isInspectionSuccessful = true;
26         let totalCost = 0;
27 
28         for (const itemEntry of declarationData.baggage.itemsList) {
29             const item = itemEntry.item;
30             const category = item.category;
31             
32             if (!category) {
33                 return res.status(404).json({ message: 'Category not found' });
34             }
35 
36             if (category.isProhibited) {
37                 isInspectionSuccessful = false;
38                 break;
39             }
40 
41             totalCost += itemEntry.quantity * item.weight * category.transportCost;
42         }
43 
44         const updatedInspection = await Inspection.findByIdAndUpdate(
45             inspectionId,
46             { status: isInspectionSuccessful ? 'awaiting_additional_review' : 'Restricted' },
47             { new: true }
48         );
49 
50         const updatedDeclaration = await Declaration.findByIdAndUpdate(
51             declarationData._id,
52             {
53                 totalCost: totalCost,
54                 status: isInspectionSuccessful ? 'awaiting_additional_review' : 'canceled'
55             },
56             { new: true }
57         );
58 
59         res.status(200).json({
60             inspection: updatedInspection,
61             declaration: updatedDeclaration
62         });
63     } catch (err) {
64         res.status(400).json({ message: err.message });
65     }
66 });

А.6 Код файлу для авторизації та реєстрації користувача auth.js


1 const express = require('express');
2 const router = express.Router();
3 const User = require('../models/User');
4 const bcrypt = require('bcryptjs');
5 const jwt = require('jsonwebtoken');
6 const { userValidationRules, validate } = require('../validation/validators');
7 
8 router.post('/login', async (req, res) => {
9     try {
10         const { email, password } = req.body;
11 
12         const user = await User.findOne({ email });
13         if (!user) {
14             return res.status(400).json({ message: 'Invalid email or password' });
15         }
16 
17 
18         const isMatch = await bcrypt.compare(password, user.password);
19         if (!isMatch) {
20             return res.status(400).json({ message: 'Invalid email or password' });
21         }
22 
23 
24         const token = jwt.sign({ userId: user._id, role: user.role }, process.env.JWT_SECRET, { expiresIn: '10h' });
25 
26         res.json({ token, userId: user._id, role: user.role });
27     } catch (err) {
28         res.status(400).json({ message: err.message });
29     }
30 });
31 
32 router.post('/register', async (req, res) => {
33     try {
34         const { name, email, password, role, phone } = req.body;
35 
36         const existingUser = await User.findOne({ email });
37         if (existingUser) {
38             return res.status(400).json({ message: 'User already exists' });
39         }
40 
41         const user = new User({ name, email, password, role, phone });
42         const newUser = await user.save();
43 
44         res.status(201).json({ message: 'User registered successfully', user: newUser });
45     } catch (err) {
46         res.status(400).json({ message: err.message });
47     }
48 });
49 
50 
51 module.exports = router; 
ДОДАТОК Б
Програмний код смарт-пристрою


1 [
2     {
3         "id": "e46394eca2066d25",
4         "type": "tab",
5         "label": "Baggage Scanners",
6         "disabled": false,
7         "info": ""
8     },
9     {
10         "id": "e50d1a62eb365ccb",
11         "type": "http in",
12         "z": "e46394eca2066d25",
13         "name": "Receive Baggage",
14         "url": "/scanBaggage",
15         "method": "post",
16         "upload": false,
17         "swaggerDoc": "",
18         "x": 130,
19         "y": 100,
20         "wires": [
21             [
22                 "979fad4d6e3a5d94"
23             ]
24         ]
25     },
26     {
27         "id": "979fad4d6e3a5d94",
28         "type": "function",
29         "z": "e46394eca2066d25",
30         "name": "Infrared Scanner",
31         "func": "msg.payload = { scanner: 'Infrared', result: 'Temperature discrepancy detected: Abnormal heat source found' };\nreturn msg;",
32         "outputs": 1,
33         "timeout": "",
34         "noerr": 0,
35         "initialize": "",
36         "finalize": "",
37         "libs": [],
38         "x": 370,
39         "y": 100,
40         "wires": [
41             [
42                 "36bf609ff4db36ab"
43             ]
44         ]
45     },
46     {
47         "id": "36bf609ff4db36ab",
48         "type": "function",
49         "z": "e46394eca2066d25",
50         "name": "Ultrasound Scanner",
51         "func": "msg.payload = { scanner: 'Ultrasound', result: 'Contraband items detected: Suspicious object found' };\nreturn msg;",
52         "outputs": 1,
53         "timeout": "",
54         "noerr": 0,
55         "initialize": "",
56         "finalize": "",
57         "libs": [],
58         "x": 640,
59         "y": 100,
60         "wires": [
61             [
62                 "c615fbada7d72292"
63             ]
64         ]
65     },
66     {
67         "id": "c615fbada7d72292",
68         "type": "function",
69         "z": "e46394eca2066d25",
70         "name": "X-ray Scanner",
71         "func": "const scanResults = [\n    'Contraband items detected: Suspicious powder found',\n    'Explosive material detected: Dangerous substance found',\n    'Contraband items detected: Suspicious object found',\n    'Unusual density detected: Hidden compartment suspected',\n    'Temperature discrepancy detected: Abnormal heat source found',\n    'Clear'\n];\n\nconst detectionChance = 0.1;\n\nconst randomValue = Math.random();\nconst result = randomValue < detectionChance\n    ? scanResults[Math.floor(Math.random() * (scanResults.length - 1))]\n    : scanResults[scanResults.length - 1]; \n\nmsg.payload = { result: result };\nreturn msg;\n",
72         "outputs": 1,
73         "timeout": "",
74         "noerr": 0,
75         "initialize": "",
76         "finalize": "",
77         "libs": [],
78         "x": 880,
79         "y": 100,
80         "wires": [
81             [
82                 "395a5ed6ab4e2043"
83             ]
84         ]
85     },
86     {
87         "id": "395a5ed6ab4e2043",
88         "type": "function",
89         "z": "e46394eca2066d25",
90         "name": "Analyze Results",
91         "func": "let status = 'allowed';\nlet errorMessage = 'No issues detected';\n\nconst results = [msg.payload];\nresults.forEach(result => {\n    if (result.result.includes('detected')) {\n        status = 'warned';\n        errorMessage = result.result;\n    }\n});\n\nmsg.payload = { status, error: errorMessage, results: results };\nreturn msg;",
92         "outputs": 1,
93         "timeout": "",
94         "noerr": 0,
95         "initialize": "",
96         "finalize": "",
97         "libs": [],
98         "x": 1140,
99         "y": 100,
100         "wires": [
101             [
102                 "cb5e1b964d75d61e"
103             ]
104         ]
105     },
106     {
107         "id": "cb5e1b964d75d61e",
108         "type": "http response",
109         "z": "e46394eca2066d25",
110         "name": "Send Result",
111         "statusCode": "",
112         "headers": {},
113         "x": 1370,
114         "y": 100,
115         "wires": []
116     }
117 ]
 
ДОДАТОК В
Програмний код клієнтської частини
В.1 Код профілю користувача Profile.js


1 import React, { useState, useEffect } from 'react';
2 import axios from 'axios';
3 import { useParams, useNavigate } from 'react-router-dom';
4 import './Profile.css';
5 
6 function Profile() {
7     const { userId } = useParams();
8     const [user, setUser] = useState(null);
9     const [loading, setLoading] = useState(true);
10     const navigate = useNavigate();
11 
12     useEffect(() => {
13         const fetchProfile = async () => {
14             try {
15                 const token = localStorage.getItem('token');
16                 const headers = { Authorization: `Bearer ${token}` };
17                 const response = await axios.get(`http://localhost:3001/user/user/${userId}`, { headers });
18                 setUser(response.data);
19                 setLoading(false);
20             } catch (error) {
21                 console.error('Error fetching profile:', error);
22                 setLoading(false);
23             }
24         };
25 
26         fetchProfile();
27     }, [userId]);
28 
29     const handleLogout = () => {
30         localStorage.removeItem('token');
31         navigate('/login');
32     };
33 
34     const formatRole = (role) => {
35         const formattedRole = role.replace('_', ' ');
36         return formattedRole.charAt(0).toUpperCase() + formattedRole.slice(1);
37     };
38 
39     const handleExportDeclarations = async () => {
40         try {
41             const token = localStorage.getItem('token');
42             const response = await axios.get(`http://localhost:3001/export/export-declarations/${userId}`, {
43                 headers: { Authorization: `Bearer ${token}` },
44                 responseType: 'blob', 
45             });
46 
47             const url = window.URL.createObjectURL(new Blob([response.data]));
48             const link = document.createElement('a');
49             link.href = url;
50             link.setAttribute('download', 'declarations_export.xlsx');
51             document.body.appendChild(link);
52             link.click();
53             document.body.removeChild(link);
54         } catch (error) {
55             console.error('Error exporting declarations:', error);
56         }
57     };
58 
59     const handleExportItems = async () => {
60         try {
61             const token = localStorage.getItem('token');
62             const response = await axios.get(`http://localhost:3001/export/export-items`, {
63                 headers: { Authorization: `Bearer ${token}` },
64                 responseType: 'blob', 
65             });
66 
67             const url = window.URL.createObjectURL(new Blob([response.data]));
68             const link = document.createElement('a');
69             link.href = url;
70             link.setAttribute('download', 'items_export.xlsx');
71             document.body.appendChild(link);
72             link.click();
73             document.body.removeChild(link);
74         } catch (error) {
75             console.error('Error exporting items:', error);
76         }
77     };
78 
79     if (loading) return <p className="loading">Loading...</p>;
80     if (!user) return <p className="user-not-found">User not found</p>;
81 
82     return (
83         <div className="profile-container">
84             <div className="profile-header">
85                 <h2 className="profile-name">{user.name}</h2>
86                 <p className="profile-email">{user.email}</p>
87             </div>
88             <div className="profile-details">
89                 <div className="profile-detail">
90                     <label>Phone</label>
91                     <p>{user.phone || '-'}</p>
92                 </div>
93                 <div className="profile-detail">
94                     <label>Role</label>
95                     <p>{formatRole(user.role)}</p>
96                 </div>
97             </div>
98 
99             <div className="role-container">
100                 {user.role === 'passenger' && (
101                     <>
102                         <button className="profile-action-button" onClick={() => navigate(`/user/${userId}/baggages`)}>My Baggage</button>
103                         <button className="profile-action-button" onClick={() => navigate(`/user/${userId}/declarations`)}>My Declarations</button>
104                         <button className="profile-action-button export-button" onClick={handleExportDeclarations}>
105                             Export Declarations
106                         </button>
107                     </>
108                 )}
109 
110                 {user.role === 'customs_officer' && (
111                     <>
112                         <button className="profile-action-button" onClick={() => navigate(`/user/${userId}/baggages-to-check`)}>Baggage to Check</button>
113                         <button className="profile-action-button" onClick={() => navigate(`/user/${userId}/inspections`)}>My Inspections</button>
114                     </>
115                 )}
116 
117                 {user.role === 'admin' && (
118                     <>
119                         <button className="profile-action-button" onClick={() => navigate(`/user/${userId}/manage-items`)}>Manage Items</button>
120                         <button className="profile-action-button" onClick={() => navigate(`/user/${userId}/manage-categories`)}>Manage Categories</button>
121                         <button className="profile-action-button export-button" onClick={handleExportItems}>
122                             Export Items
123                         </button>
124                     </>
125                 )}
126             </div>
127 
128             <div className="profile-actions">
129                 <button className="profile-action-button" onClick={() => navigate(`/user/${userId}/edit`)}>
130                     Edit Profile
131                 </button>
132                 <button className="logout-button" onClick={handleLogout}>
133                     Logout
134                 </button>
135             </div>
136         </div>
137     );
138 }
139 
140 export default Profile;

В.2 Код сторінки з інспекціями Inspections.js


1 import React, { useState, useEffect } from 'react';
2 import axios from 'axios';
3 import { useParams } from 'react-router-dom';
4 import './Inspections.css';
5 
6 function UserInspections() {
7     const { userId } = useParams();
8     const [inspections, setInspections] = useState([]);
9     const [loading, setLoading] = useState(true);
10     const [error, setError] = useState(null);
11     const [selectedInspection, setSelectedInspection] = useState(null);
12     const [editedNotes, setEditedNotes] = useState('');
13     const [inspectors, setInspectors] = useState({});
14 
15     useEffect(() => {
16         const fetchInspections = async () => {
17             try {
18                 const token = localStorage.getItem('token');
19                 const headers = { Authorization: `Bearer ${token}` };
20                 const response = await axios.get(`http://localhost:3001/inspection/${userId}/inspections`, { headers });
21                 setInspections(response.data);
22                 
23                 const fetchInspectors = async () => {
24                     const inspectorPromises = response.data.map(async (inspection) => {
25                         if (inspection.inspector && !inspectors[inspection.inspector]) {
26                             try {
27                                 const inspectorResponse = await axios.get(`http://localhost:3001/user/user/${inspection.inspector}`, { headers });
28                                 setInspectors(prev => ({ ...prev, [inspection.inspector]: inspectorResponse.data.name }));
29                             } catch (error) {
30                                 console.error('Error fetching inspector data:', error);
31                             }
32                         }
33                         return inspection;
34                     });
35                     await Promise.all(inspectorPromises);
36                 };
37 
38                 await fetchInspectors();
39                 setLoading(false);
40             } catch (error) {
41                 console.error('Error fetching inspections:', error);
42                 setError('Error fetching inspections');
43                 setLoading(false);
44             }
45         };
46         fetchInspections();
47     }, [userId, inspectors]);
48 
49     const handleInspectClick = async () => {
50         try {
51             const token = localStorage.getItem('token');
52             const headers = { Authorization: `Bearer ${token}` };
53             const response = await axios.post('http://localhost:3001/inspection/doinspection', 
54                 { inspectionId: selectedInspection._id },
55                 { headers }
56             );
57             console.log('Inspection processed:', response.data);
58             setSelectedInspection(null);
59             const updatedResponse = await axios.get(`http://localhost:3001/inspection/${userId}/inspections`, { headers });
60             setInspections(updatedResponse.data);
61         } catch (error) {
62             console.error('Error inspecting:', error);
63             setError('Error processing inspection');
64         }
65     };
66 
67     const handleMakeAdditionalInspection = async () => {
68         try {
69             const token = localStorage.getItem('token');
70             const headers = { Authorization: `Bearer ${token}` };
71             const response = await axios.post('http://localhost:3001/inspection/finalinspection', 
72                 { inspectionId: selectedInspection._id },
73                 { headers }
74             );
75             console.log('Final inspection processed:', response.data);
76             setSelectedInspection(null);
77             const updatedResponse = await axios.get(`http://localhost:3001/inspection/${userId}/inspections`, { headers });
78             setInspections(updatedResponse.data);
79         } catch (error) {
80             console.error('Error making additional inspection:', error);
81             setError('Error processing additional inspection');
82         }
83     };
84 
85     const handleNotesChange = (e) => {
86         setEditedNotes(e.target.value);
87     };
88 
89     const handleSaveNotes = async () => {
90         try {
91             const token = localStorage.getItem('token');
92             const headers = { Authorization: `Bearer ${token}` };
93             await axios.put(`http://localhost:3001/inspection/inspection/${selectedInspection._id}`, 
94                 { notes: editedNotes },
95                 { headers }
96             );
97             console.log('Notes updated');
98             
99             setInspections(inspections.map(ins => 
100                 ins._id === selectedInspection._id 
101                 ? { ...ins, notes: editedNotes } 
102                 : ins
103             ));
104         } catch (error) {
105             console.error('Error updating notes:', error);
106             setError('Error updating notes');
107         }
108     };
109 
110     if (loading) return <p className="loading">Loading...</p>;
111     if (error) return <p className="error">{error}</p>;
112 
113     return (
114         <div className="inspections-container">
115             <h2>Your Inspections</h2>
116             <div className="inspections-row">
117                 {inspections.length > 0 ? (
118                     inspections.map((inspection, index) => (
119                         <div
120                             key={inspection._id}
121                             className={`inspection-card ${inspection.status === 'restricted' ? 'restricted' : ''}`}
122                             onClick={() => {
123                                 setSelectedInspection(inspection);
124                                 setEditedNotes(inspection.notes);
125                             }}
126                         >
127                             <p className="inspection-title">Inspection {index + 1}</p>
128                             <p className={`inspection-status ${inspection.status}`}>
129                                 Status: {inspection.status}
130                             </p>
131                             <p className="inspection-date">Inspected At: {new Date(inspection.inspectedAt).toLocaleDateString()}</p>
132                         </div>
133                     ))
134                 ) : (
135                     <p className="no-inspections">No inspections found</p>
136                 )}
137             </div>
138             {selectedInspection && (
139                 <div className="inspection-details">
140                     <h3>Inspection Details</h3>
141                     <p><strong>Status:</strong> <span className={`inspection-status ${selectedInspection.status}`}>{selectedInspection.status}</span></p>
142                     <p><strong>Inspected At:</strong> {new Date(selectedInspection.inspectedAt).toLocaleDateString()}</p>
143                     <p><strong>Inspector:</strong> {inspectors[selectedInspection.inspector] || 'Unknown'}</p>
144                     <p><strong>Declaration ID:</strong> {selectedInspection.declaration._id}</p>
145                     <textarea 
146                         value={editedNotes} 
147                         onChange={handleNotesChange} 
148                         rows="4"
149                         placeholder="Edit notes..."
150                     />
151                     <button className="save-notes-button" onClick={handleSaveNotes}>
152                         Save Notes
153                     </button>
154                     {selectedInspection.status === 'waiting_for_inspection' && (
155                         <button className="inspect-button" onClick={handleInspectClick}>
156                             Inspect
157                         </button>
158                     )}
159                     {selectedInspection.status === 'awaiting_additional_review' && (
160                         <button className="make-additional-inspection-button" onClick={handleMakeAdditionalInspection}>
161                             Make Additional Inspection
162                         </button>
163                     )}
164                     {selectedInspection.status === 'restricted' && (
165                         <p className="restricted-message">This inspection is restricted and cannot be processed further.</p>
166                     )}
167                     <button className="close-details" onClick={() => setSelectedInspection(null)}>
168                         Close
169                     </button>
170                 </div>
171             )}
172         </div>
173     );
174 }
175 
176 export default UserInspections;

В.3 Код сторінки редагування категорій Categories.js


1 import React, { useState, useEffect } from 'react';
2 import axios from 'axios';
3 import './Categories.css';
4 
5 function Categories() {
6     const [categories, setCategories] = useState([]);
7     const [loading, setLoading] = useState(true);
8     const [error, setError] = useState(null);
9     const [showModal, setShowModal] = useState(false);
10     const [editMode, setEditMode] = useState(false);
11     const [categoryForm, setCategoryForm] = useState({
12         _id: '',
13         name: '',
14         description: '',
15         isProhibited: false,
16         transportCost: 0,
17     });
18 
19     useEffect(() => {
20         const fetchCategories = async () => {
21             try {
22                 const token = localStorage.getItem('token');
23                 const headers = { Authorization: `Bearer ${token}` };
24                 const response = await axios.get('http://localhost:3001/category/categories', { headers });
25                 setCategories(response.data);
26                 setLoading(false);
27             } catch (error) {
28                 console.error('Error fetching categories:', error);
29                 setError('Error fetching categories');
30                 setLoading(false);
31             }
32         };
33         fetchCategories();
34     }, []);
35 
36     const openModal = (category = null) => {
37         if (category) {
38             setEditMode(true);
39             setCategoryForm({ ...category });
40         } else {
41             setEditMode(false);
42             setCategoryForm({
43                 name: '',
44                 description: '',
45                 isProhibited: false,
46                 transportCost: 0,
47             });
48         }
49         setShowModal(true);
50     };
51 
52     const closeModal = () => {
53         setShowModal(false);
54     };
55 
56     const handleSaveCategory = async () => {
57         try {
58             const token = localStorage.getItem('token');
59             const headers = { Authorization: `Bearer ${token}` };
60 
61             if (editMode) {
62                 await axios.put(`http://localhost:3001/category/category/${categoryForm._id}`, categoryForm, { headers });
63             } else {
64                 await axios.post('http://localhost:3001/category/category', categoryForm, { headers });
65             }
66 
67             const response = await axios.get('http://localhost:3001/category/categories', { headers });
68             setCategories(response.data);
69             closeModal();
70         } catch (error) {
71             console.error('Error saving category:', error);
72             setError('Error saving category');
73         }
74     };
75 
76     const handleDeleteCategory = async (categoryId) => {
77         try {
78             const token = localStorage.getItem('token');
79             const headers = { Authorization: `Bearer ${token}` };
80             await axios.delete(`http://localhost:3001/category/category/${categoryId}`, { headers });
81 
82             const response = await axios.get('http://localhost:3001/category/categories', { headers });
83             setCategories(response.data);
84         } catch (error) {
85             console.error('Error deleting category:', error);
86             setError('Error deleting category');
87         }
88     };
89 
90     if (loading) return <p className="loading">Loading...</p>;
91     if (error) return <p className="error">{error}</p>;
92 
93     return (
94         <div className="categories-container">
95             <h2>Categories</h2>
96             <div className="categories-row">
97                 {categories.length > 0 ? (
98                     categories.map((category) => (
99                         <div key={category._id} className="category-card">
100                             <h3 className="category-name">{category.name}</h3>
101                             <p className="category-description">{category.description}</p>
102                             <p className="category-transport-cost">
103                                 Transport Cost: {category.transportCost} $
104                             </p>
105                             <p 
106                                 className={`category-is-prohibited ${category.isProhibited ? 'prohibited' : 'allowed'}`}
107                             >
108                                 {category.isProhibited ? 'Prohibited' : 'Allowed'}
109                             </p>
110                             <div className="category-buttons">
111                                 <button 
112                                     className="button edit-button" 
113                                     onClick={() => openModal(category)}
114                                 >
115                                     Edit
116                                 </button>
117                                 <button 
118                                     className="button delete-button" 
119                                     onClick={() => handleDeleteCategory(category._id)}
120                                 >
121                                     Delete
122                                 </button>
123                             </div>
124                         </div>
125                     ))
126                 ) : (
127                     <p className="no-categories">No categories found</p>
128                 )}
129                 <div className="category-card add-category-card" onClick={() => openModal()}>
130                     <div className="plus-icon">+</div>
131                     <div className="add-text">Add Category</div>
132                 </div>
133             </div>
134 
135             {}
136             {showModal && (
137                 <div className="modal">
138                     <div className="modal-content">
139                         <h3>{editMode ? 'Edit Category' : 'Add New Category'}</h3>
140                         <form onSubmit={(e) => { e.preventDefault(); handleSaveCategory(); }}>
141                             <label>Name</label>
142                             <input 
143                                 type="text" 
144                                 value={categoryForm.name} 
145                                 onChange={(e) => setCategoryForm({ ...categoryForm, name: e.target.value })}
146                                 required 
147                             />
148 
149                             <label>Description</label>
150                             <textarea 
151                                 value={categoryForm.description} 
152                                 onChange={(e) => setCategoryForm({ ...categoryForm, description: e.target.value })}
153                             />
154 
155                             <label>Transport Cost</label>
156                             <input 
157                                 type="number" 
158                                 value={categoryForm.transportCost} 
159                                 onChange={(e) => setCategoryForm({ ...categoryForm, transportCost: parseFloat(e.target.value) })}
160                                 required 
161                             />
162 
163                             <label>Status</label>
164                             <select 
165                                 value={categoryForm.isProhibited} 
166                                 onChange={(e) => setCategoryForm({ ...categoryForm, isProhibited: e.target.value === 'true' })}
167                             >
168                                 <option value="false">Allowed</option>
169                                 <option value="true">Prohibited</option>
170                             </select>
171 
172                             <div className="modal-buttons">
173                                 <button type="submit" className="button save-button">
174                                     {editMode ? 'Save Changes' : 'Add Category'}
175                                 </button>
176                                 <button type="button" className="button cancel-button" onClick={closeModal}>
177                                     Cancel
178                                 </button>
179                             </div>
180                         </form>
181                     </div>
182                 </div>
183             )}
184         </div>
185     );
186 }
187 
188 export default Categories;

 
ДОДАТОК Г
Результат перевірки на плагіат

 
Рисунок Г.1 – Результат перевірки на плагіат.

 
Рисунок Г.2 – Друга частина перевірки на плагіат.


 
Рисунок Г.3 – Остання частина перевірки на плагіат.

